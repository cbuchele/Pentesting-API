from fastapi import FastAPI, File, Form, UploadFile, HTTPException
from fastapi.responses import FileResponse
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from typing import Optional
from reportlab.lib.pagesizes import letter
from reportlab.pdfgen import canvas
import subprocess
import logging
import os
import tempfile
import requests

app = FastAPI()

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Function to run commands
def run_command(command):
    process = subprocess.Popen(command.split(), stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    output, error = process.communicate()
    return output.decode(), error.decode()

# Model for JSON body
class ScanModel(BaseModel):
    target: str
    param: Optional[str] = None
    credentials: Optional[str] = None


def create_pdf_report(report_data):
    # Create a new PDF document
    pdf_filename = "pentest_report.pdf"
    c = canvas.Canvas(pdf_filename, pagesize=letter)
    
    # Set up the layout
    c.setFont("Helvetica-Bold", 16)
    c.drawString(100, 750, "Penetration Test Report")
    
    c.setFont("Helvetica", 12)
    y_position = 700
    
    # Add sections based on report data
    for section_title, section_content in report_data.items():
        # Add section title
        c.setFont("Helvetica-Bold", 14)
        c.drawString(100, y_position, section_title)
        y_position -= 20
        
        # Add section content
        c.setFont("Helvetica", 12)
        for item in section_content:
            c.drawString(120, y_position, item)
            y_position -= 15
        
        # Add spacing between sections
        y_position -= 10
    
    # Save the PDF document
    c.save()
    
    return pdf_filename
@app.post("/full_scan", summary="Perform a full scan including various tests")
async def full_scan(
    target: str = Form(...),
    param: str = Form(...),
    credentials: str = Form(...),
    wordlist: UploadFile = File(...),
    upload_file: UploadFile = File(...),
    password_list_file: UploadFile = File(...),
    useragents_file: Optional[UploadFile] = File(None)
):
    if not target or not param or not credentials:
        raise HTTPException(status_code=400, detail="Missing required parameters")

    report = []

    # Save uploaded files temporarily
    temp_files = []
    wordlist_path = tempfile.NamedTemporaryFile(delete=False)
    wordlist_path.write(await wordlist.read())
    temp_files.append(wordlist_path.name)

    if useragents_file:
        useragents_path = tempfile.NamedTemporaryFile(delete=False)
        useragents_path.write(await useragents_file.read())
        temp_files.append(useragents_path.name)
    else:
        useragents_path = None

    upload_path = tempfile.NamedTemporaryFile(delete=False)
    upload_path.write(await upload_file.read())
    temp_files.append(upload_path.name)

    password_list_path = tempfile.NamedTemporaryFile(delete=False)
    password_list_path.write(await password_list_file.read())
    temp_files.append(password_list_path.name)

    # Nmap scan
    command = f'nmap -sS -sV -T4 {target}'
    output, error = run_command(command)
    report.append(f'Nmap scan result for {target}:\n{output}\n{error}')

    # XSS test
    payload = "<script>alert('XSS')</script>"
    report.append(f'XSS test for {target} with payload {payload}:\nXSS test completed\n')

    # SQLi test
    sqli_payload = "' OR '1'='1"
    full_url = f'{target}?{param}={sqli_payload}'
    command = f'sqlmap -u "{full_url}" --batch'
    output, error = run_command(command)
    report.append(f'SQLi test result for {target} with param {param}:\n{output}\n{error}')

    # CSRF test
    csrf_payload = f'''
    <form action="{target}" method="POST">
        <input type="hidden" name="csrf_token" value="invalid_token">
        <input type="submit" value="Submit">
    </form>
    '''
    report.append(f'CSRF test for {target} with payload:\n{csrf_payload}\nCSRF test completed\n')

    # File upload test
    command = f'curl -F "file=@{upload_path.name}" {target}'
    output, error = run_command(command)
    report.append(f'File upload test result for {target} with file {upload_path.name}:\n{output}\n{error}')

    # Privilege escalation test
    session = requests.Session()
    login_url = f'{target}/login'
    response = session.post(login_url, data={'credentials': credentials})
    if 'welcome' in response.text.lower():
        escalation_payload = {'action': 'escalate'}
        escalation_url = f'{target}/admin'
        escalation_response = session.post(escalation_url, data=escalation_payload)
        report.append(f'Privilege escalation test result for {target}:\n{escalation_response.text}')
    else:
        report.append(f'Login failed for privilege escalation test on {target}')

    # Rate limit test
    username = 'admin'
    command = f'hydra -l {username} -P {password_list_path.name} {target} http-post-form "/login:username=^USER^&password=^PASS^:F=incorrect"'
    output, error = run_command(command)
    report.append(f'Rate limiting and brute force test result for {target}:\n{output}\n{error}')

    # Directory brute force
    command = f'urlbuster -W {wordlist_path.name} -m "GET,POST" {target}'
    if useragents_path:
        command += f' -A {useragents_path.name}'
    output, error = run_command(command)
    report.append(f'Directory brute force result for {target}:\n{output}\n{error}')

    # Prepare report data for PDF generation
    report_data = {
        "Nmap Scan Results": [f'Nmap scan result for {target}:\n{output}\n{error}'],
        "XSS Test": [f'XSS test for {target} with payload {payload}:\nXSS test completed'],
        "SQLi Test": [f'SQLi test result for {target} with param {param}:\n{output}\n{error}'],
        "CSRF Test": [f'CSRF test for {target} with payload:\n{csrf_payload}\nCSRF test completed'],
        "File Upload Test": [f'File upload test result for {target} with file {upload_path.name}:\n{output}\n{error}'],
        "Privilege Escalation Test": [f'Privilege escalation test result for {target}:\n{escalation_response.text}'],
        "Rate Limit Test": [f'Rate limiting and brute force test result for {target}:\n{output}\n{error}'],
        "Directory Brute Force": [f'Directory brute force result for {target}:\n{output}\n{error}']
    }

    # Generate PDF report
    pdf_filename = create_pdf_report(report_data)

    # Cleanup temporary files
    for temp_file in temp_files:
        os.remove(temp_file)

    return FileResponse(pdf_filename, filename='pentest_report.pdf')

@app.post("/scan", summary="Perform a scan using Nmap on the provided target")
async def scan(scan_data: ScanModel):
    if not scan_data.target:
        raise HTTPException(status_code=400, detail="No target provided")

    command = f'nmap -sS -sV -T4 {scan_data.target}'
    output, error = run_command(command)

    logging.info(f'Scan result for {scan_data.target}: {output}')

    return {"result": output}

@app.post("/xss_test", summary="Perform an XSS test on the provided target")
async def xss_test(scan_data: ScanModel):
    if not scan_data.target:
        raise HTTPException(status_code=400, detail="No target provided")

    payload = "<script>alert('XSS')</script>"
    headers = {'Content-Type': 'application/x-www-form-urlencoded'}
    data = {'comment': payload}
    response = requests.post(scan_data.target, headers=headers, data=data)

    return {"result": "XSS test successful"}

@app.post("/sqli_test", summary="Perform an SQLi test on the provided target with a parameter")
async def sqli_test(scan_data: ScanModel):
    if not scan_data.target or not scan_data.param:
        raise HTTPException(status_code=400, detail="Missing target or param")

    sqli_payload = "' OR '1'='1"
    full_url = f'{scan_data.target}?{scan_data.param}={sqli_payload}'

    try:
        response = requests.get(full_url)
        if response.status_code == 200 and 'error' not in response.text.lower():
            app.logger.info(f'SQLi test for {scan_data.target} with param {scan_data.param} succeeded')
            return {"result": "SQLi test successful"}
        else:
            app.logger.warning(f'SQLi test for {scan_data.target} with param {scan_data.param} failed')
            return {"result": "SQLi test failed"}
    except Exception as e:
        app.logger.error(f'SQLi test for {scan_data.target} with param {scan_data.param} encountered an error: {str(e)}')
        raise HTTPException(status_code=500, detail="SQLi test failed due to an error")

@app.post("/csrf_test", summary="Perform a CSRF test on the provided target")
async def csrf_test(scan_data: ScanModel):
    if not scan_data.target:
        raise HTTPException(status_code=400, detail="No target provided")

    csrf_payload = f'''
    <form action="{scan_data.target}" method="POST">
        <input type="hidden" name="csrf_token" value="invalid_token">
        <input type="submit" value="Submit">
    </form>
    '''
    response = requests.post(scan_data.target, data={'csrf_token': 'invalid_token'})

    if 'csrf_token' not in response.text:
        test_result = 'CSRF vulnerability detected'
    else:
        test_result = 'CSRF protection seems effective'

    logging.info(f'CSRF test for {scan_data.target} with payload:\n{csrf_payload}')

    return {"result": test_result}

@app.post("/file_upload_test", summary="Perform a file upload test on the provided target")
async def file_upload_test(target: str = Form(...), upload_file: UploadFile = File(...)):
    if not target:
        raise HTTPException(status_code=400, detail="No target provided")

    filename = secure_filename(upload_file.filename)
    upload_path = tempfile.NamedTemporaryFile(delete=False, suffix=filename)
    upload_path.write(await upload_file.read())
    upload_path.close()

    command = f'curl -F "file=@{upload_path.name}" {target}'
    subprocess.run(command, shell=True, check=True)

    os.remove(upload_path.name)

    return {"result": "File upload test completed"}

@app.post("/privilege_escalation_test", summary="Perform a privilege escalation test on the provided target")
async def privilege_escalation_test(scan_data: ScanModel):
    if not scan_data.target or not scan_data.credentials:
        raise HTTPException(status_code=400, detail="Missing target or credentials")

    session = requests.Session()
    login_url = f'{scan_data.target}/login'
    response = session.post(login_url, data={'credentials': scan_data.credentials})

    if 'welcome' in response.text.lower():
        escalation_payload = {'action': 'escalate'}
        escalation_url = f'{scan_data.target}/admin'
        escalation_response = session.post(escalation_url, data=escalation_payload)
        result = escalation_response.text
    else:
        result = 'Login failed for privilege escalation test'

    logging.info(f'Privilege escalation test for {scan_data.target}: {result}')

    return {"result": result}

@app.post("/rate_limit_test", summary="Perform a rate limit test on the provided target")
async def rate_limit_test(target: str = Form(...), username: str = Form(...), password_list: UploadFile = File(...)):
    if not target or not username:
        raise HTTPException(status_code=400, detail="Missing target or username")

    password_list_path = tempfile.NamedTemporaryFile(delete=False)
    password_list_path.write(await password_list.read())
    password_list_path.close()

    command = f'hydra -l {username} -P {password_list_path.name} {target} http-post-form "/login:username=^USER^&password=^PASS^:F=incorrect"'
    output, error = run_command(command)

    os.remove(password_list_path.name)

    return {"result": output}

@app.post("/dir_bruteforce", summary="Perform a directory brute force test on the provided target")
async def dir_bruteforce(target: str = Form(...), wordlist: UploadFile = File(...), useragents: Optional[UploadFile] = File(None)):
    if not target:
        raise HTTPException(status_code=400, detail="No target provided")

    wordlist_path = tempfile.NamedTemporaryFile(delete=False)
    wordlist_path.write(await wordlist.read())
    wordlist_path.close()

    command = f'urlbuster -W {wordlist_path.name} -m "GET,POST" {target}'

    if useragents:
        useragents_path = tempfile.NamedTemporaryFile(delete=False)
        useragents_path.write(await useragents.read())
        useragents_path.close()
        command += f' -A {useragents_path.name}'
    else:
        useragents_path = None

    output, error = run_command(command)

    os.remove(wordlist_path.name)
    if useragents_path:
        os.remove(useragents_path.name)

    return {"result": output}
